// Список команд для датчика температуры
// Использование OneWire.write(0xCommand)

// Search Rom [F0h]:
// Когда система сначала включается, мастер должен идентифицировать коды ПЗУ всех подчиненных устройств на шине, 
// что позволяет мастеру определять количество ведомых устройств и их типы устройств. 
// Мастер изучает коды ПЗУ посредством процесса устранения, который требует, 
// чтобы мастер выполнял цикл поиска ROM (т. Е. Команду поиска ROM, за которой следует обмен данными) столько раз, 
// сколько необходимо для идентификации всех подчиненных устройств. Если на шине имеется только один ведомый, 
// более простая команда чтения ROM [33h] может использоваться вместо процесса поиска ROM. Подробное описание процедуры поиска ROM см. 
// В приложении «Примечание 937: Книга стандартов iButton®». 
// После каждого цикла поиска ROM мастер шины должен вернуться к шагу 1 (инициализация) в последовательности транзакций.
//
// Read Rom [33h]:
// Эта команда может использоваться только тогда, когда на шине есть один ведомый. 
// Он позволяет ведущему устройству считывать 64-битный код ПЗУ без использования процедуры поиска ROM. 
// Если эта команда используется, когда на шине присутствует более одного подчиненного устройства, 
// произойдет столкновение данных, когда все подчиненные попытаются ответить одновременно.
//
// Match Rom [55H]:
// Команда ПЗУ совпадения, за которой следует 64-битная последовательность кода ПЗУ, 
// позволяет ведущему устройству шины адресовать конкретное ведомое устройство на многоточечной или однодисковой шине.
// Только подчиненное устройство, которое точно соответствует кодовой последовательности 64-битного ПЗУ, будет отвечать на команду функции, 
// выдаваемую мастером; Все остальные ведомые устройства на шине будут ждать импульса сброса.
//
// Skip Rom [CCh]:
// Мастер может использовать эту команду для одновременного адресации всех устройств на шине без отправки какой-либо информации о кодах ПЗУ. 
// Например, мастер может заставить все DS18B20s на шине выполнять одновременные преобразования температуры,
// выдав команду Skip ROM, а затем команду Convert T [44h]. 
// Обратите внимание, что команда Read Scratchpad [BEh] может следовать команде Skip ROM только в том случае, если на шине имеется одно ведомое устройство. 
// В этом случае время сохраняется, позволяя мастеру читать из подчиненного устройства без отправки 64-битного кода ROM устройства. 
// Если вызвать команду Пропустить ПЗУ, а после вызвать команду прочитать Scratchpad, то это вызовет столкновение данных на шине, 
// если есть несколько подчиненных устройств, поскольку несколько устройств будут пытаться передавать данные одновременно.
//
// Alarm Search [ECh]:
// Работа этой команды идентична работе команды поиска ROM, за исключением того, 
// что будут отвечать только ведомые устройства с установленным сигналом тревоги. 
// Эта команда позволяет главному устройству определить, не возникло ли у какого-либо DS18B20s условие тревоги во время последнего температурного преобразования. 
// После каждого цикла поиска тревог (т. Е. Команды поиска сигнала, за которым следует обмен данными) ведущий сервер шины 
// должен вернуться к шагу 1 (инициализация) в последовательности транзакций. См. Раздел «Сигнализация Operation-Alarm Signaling» для объяснения операции флага тревоги.

// После того как мастер шины использовал команду ПЗУ для адреса DS18B20, с которой он хочет общаться, 
// мастер может выдать одну из функциональных команд DS18B20. Эти команды позволяют мастеру записывать и считывать данные из памяти блокнота DS18B20, 
// инициировать температурные преобразования и определять режим питания.

// Convert T [44h]:
// Эта команда инициирует одно преобразование температуры. 
// После преобразования результирующие тепловые данные сохраняются в 2-байтовом температурном регистре в памяти блокнотной памяти, 
// а DS18B20 возвращается в малое рабочее состояние холостого хода. 
// Если устройство используется в режиме питания от паразитов, в течение 10 мкс (макс.) 
// После выдачи этой команды мастер должен включить сильное подтягивание на 1-й шине на время преобразования (tCONV).
// Если DS18B20 питается от внешнего источника, мастер может выдавать интервалы времени считывания после команды Convert T, 
// и DS18B20 будет отвечать, передавая 0, пока выполняется преобразование температуры, и 1, когда выполняется преобразование. 
// В режиме питания паразитов этот метод уведомления не может быть использован, поскольку шина вытягивается высоко за счет сильного подтягивания во время преобразования.
//
// Write Scratchpad [4Eh]:
// Эта команда позволяет мастеру записывать 3 байта данных в блокнот DS18B20. 
// Первый байт данных записывается в регистр TH (байт 2 блокнота), второй байт записывается в регистр TL (байт 3), 
// а третий байт записывается в регистр конфигурации (байт 4). Сначала данные должны быть переданы младшим значащим бит. 
// Все три байта ДОЛЖНЫ быть записаны до того, как мастер выдает сброс, или данные могут быть повреждены.
//
// Read Scratchpad [BEh]:
// Эта команда позволяет мастеру прочитать содержимое блокнота. 
// Передача данных начинается с младшего значащего разряда байта 0 и продолжается через блокнот до тех пор, пока не будет прочитан 9-й байт (байт 8-CRC). 
// Мастер может выполнить сброс, чтобы прекратить чтение в любое время, если требуется только часть данных блокнотной памяти.
//
// Copy Scratchpad [48h]:
// Эта команда копирует содержимое блокнота TH, TL и конфигурационных регистров (байты 2, 3 и 4) в EEPROM. 
// Если устройство используется в режиме питания от паразитов, в течение 10 мкс (макс.) 
// После выдачи этой команды мастер должен включить сильное подтягивание на шине 1-Wire не менее 10 мс, как описано в разделе «Включение питания DS18B20».
//
// Recall E2 [B8h]:
// Эта команда вызывает значения триггера тревоги (TH и TL) и данные конфигурации из EEPROM и помещает данные в байтах 2, 3 и 4 соответственно 
// в память блокнотной памяти. Ведущее устройство может выдавать интервалы времени считывания после команды Recall E2,
// а DS18B20 будет указывать статус отзыва, передавая 0 во время повторного вызова и 1, когда вызов будет выполнен. 
// Операция отзыва происходит автоматически при включении питания, поэтому действительные данные доступны на блокноте сразу после подачи питания на устройство.
//
// Read Power Supply [B4h]:
// Ведущее устройство выдает эту команду, за которой следует временной интервал чтения, чтобы определить, 
// использует ли DS18B20s на шине мощность паразита. Во время временного интервала считывания DS18B20s с питанием от паразита вытащит шину на низком уровне, 
// а DS18B20s с внешним питанием позволят шине оставаться высокой. Информацию об использовании этой команды см. В разделе «Включение раздела DS18B20».

#include <OneWire.h>

OneWire  ds(10);  // Создаём объект OneWire на 10-ом пине (нужен резистор в 4.7кОм)

void setup(void) 
{
	Serial.begin(9600);	// Начинаем последовательный вывод информации
}

void loop(void) 
{
	byte i;	// Это счётчик, byte используем для экономии памяти
	byte present = 0;
  	byte type_s;
  	byte data[12];
  	byte addr[16][8];
  	float celsius;
  	
  	// Ищем доступные устройства
  	for (i = 0; i < 16; i++)
  	{
  		if (!ds.search(addr))	// Если их нет, выводим сообщение об этом
  		{
    		Serial.println("No more addresses.");
    		Serial.println();
    		ds.reset_search();
    		
    		break;	// Снова возвращаемся в цикл
  		}
  	}
  	
  	
  	// Если нашли устройство, печатаем его номер
  	Serial.print("ROM =");
  	for( i = 0; i < 8; i++)
  	{
    	Serial.write(' ');
    	Serial.print(addr[i], HEX);
  	}

  	// Проверка целостности данных
  	if (OneWire::crc8(addr, 7) != addr[7])	// Если crc ключ не совпадает, выводим сообщение об ошибке
  	{
    	Serial.println("CRC is not valid!");
    	return;
  	}
  	Serial.println();
 
  	// Перейдём к считыванию информации с датчиков
  	ds.reset();	// Для начала сбросим наше устройство (вернёт 1, если подключено) 
  	ds.select(addr);	// Выберем наше устройство (сейчас оно у нас одно)
  	ds.write(0x44);        // Начинаем преобразование //(паразитное питание ds.write(0x44, 1); )
 	// Код 0x44 -- это команда выполнить температурную конверсию
  	delay(750);     // Для того, чтобы конвертировалось, нужно подождать секунду (750 милисекунд должно хватить)
  	// Теперь наши данные температуры лежат в памяти самого датчика
  	// Далее мы должны использовать .depower(), чтобы считывать данные дальше, но .reset() позаботится об этом
  
  	present = ds.reset();	// Флаг, показывающий отвечает нам устройство или нет
  	ds.select(addr);	// Снова выбираем этот датчик
  	ds.write(0xBE);         // Читаем его память (Scratchpad)

  	Serial.print("  Data = ");
  	Serial.print(present, HEX);	// Флаг ответа.
  	Serial.print(" ");
  	for ( i = 0; i < 9; i++) // Нам нужно считать 9 байт         
    	data[i] = ds.read();

  	// Преобразуем данные в реальную температуру.
  	// Convert the data to actual temperature
  	// because the result is a 16 bit signed integer, it should
  	// be stored to an "int16_t" type, which is always 16 bits
  	// even when compiled on a 32 bit processor.
  	int16_t raw = (data[1] << 8) | data[0];

  	celsius = (float)raw / 16.0;
  	Serial.print("  Temperature = ");
  	Serial.print(celsius);
  	Serial.print(" Celsius, ");
}

